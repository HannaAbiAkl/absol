%DocumentClass
\documentclass[a4paper,11pt]{report}

%Additional Packages
\usepackage{scrextend} %for variable indentation
\usepackage{algorithm} %For algorithms
\usepackage{algpseudocode} %For algorithms
\usepackage[]{array}
\usepackage{amsmath} %Extra formula-writing functionality
\usepackage{amssymb} %More formula-writing functionality
\usepackage[toc]{appendix}
\usepackage{bm}
\usepackage{bold-extra} %Small caps
\usepackage{caption}
\usepackage{color} %Colour stuff (mostly for the highlight custom command)
\usepackage{enumerate} %For lists
\usepackage{fancyhdr}
\usepackage{float} %better float control
\usepackage[utf8]{inputenc} %for font encoding
\usepackage{framed} %For frames around blocks
\usepackage[top=2.5cm, bottom=2.5cm, left=3cm, right=3cm]{geometry} %Fix page margins
\usepackage[hidelinks]{hyperref} %For URL formleatting (makes clickable links)
\usepackage[toc, xindy, acronym, nonumberlist, nopostdot]{glossaries}
\usepackage{graphicx} %For including images, etc.
\usepackage{listings} %For including code
\usepackage{longtable} %for multi-page tables
\usepackage{mathrsfs} %For maths script fonts
\usepackage{newclude}
\usepackage{titling}
\usepackage{titlesec}
\usepackage[nottoc]{tocbibind}
\usepackage[]{natbib} %For the bibliography
%\usepackage[superscript]{cite}
\usepackage{pdfpages} %For including PDFs
\usepackage{stmaryrd}
\usepackage{subcaption}
\usepackage{tabu} %more pretty tables
\usepackage{tabulary} %for nice tables
\usepackage{tabularx} %also for nice tables
\usepackage{ulem}
\usepackage{xcolor}
\usepackage{xparse}
\usepackage{textcomp}
\usepackage[prefix=sol-]{xcolor-solarized}

\usepackage{relsize}

%CustomCommands
\newcommand{\highlight}[1]{\colorbox{yellow}{#1}} %Highlights text
\newcommand{\limplies}{\to} %Creates the logical implication sign
\newcommand{\liff}{\leftrightarrow} %Creates the double logical implication sign
\newcommand{\leftabs}{\left\lvert} %Left absolute value bracket
\newcommand{\rightabs}{\right\rvert} %Right absolute value bracket
\newcommand{\textbsc}[1]{\textsc{\textbf{#1}}}
%\renewcommand\thesubsection{(\alph{subsection})} %Make subsections alphabetical
\newcommand{\id}{\hspace*{12pt}}
\newcommand{\newpar}{\vspace{12pt}}
\newcommand{\lam}{$\lambda$}
\newcommand{\alp}{$\alpha$}
\newcommand{\bet}{$\beta$}
\newcommand{\aequiv}{=_\alpha}
\newcommand{\bequiv}{=_\beta}
\newcommand{\bconv}{\limplies_\beta}
\newcommand{\context}{$\Gamma$}
\newcommand{\rspace}{\;\;\;\;\;\;\;\;}
\newcommand{\eval}{\Downarrow}

% New Table Column Types
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

% Syntax: \newdualentry[glossary options][acronym options]{label}{abbrv}{long}{description}
\DeclareDocumentCommand{\newdualentry}{ O{} O{} m m m m } {
    \newglossaryentry{gls-#3}{name={#5},text={#5\glsadd{#3}},
        description={#6},#1
    }
    % \makeglossaries
    \newacronym[first=#5, firstplural=#5s, see={[Glossary:]{gls-#3}},#2]{#3}{#4}{#5 \glsseeformat[Glossary:]{gls-#3}{#5}\glsadd{gls-#3}}
    % \newacronym[see={[Glossary:]{gls-#3}},#2]{#3}{#4}{#5\glsadd{gls-#3}}
}

% For quoting \quoteit{quote}{attribution}
\newcommand{\quoteit}[2]{
    \begin{longtable}{p{14cm}}
        \textit{``#1''} \\
        % \hspace{5mm} --- #2 
        \begin{tabular}{R{14cm}}
            --- #2
        \end{tabular}
    \end{longtable}
}

% For definitions \defblock{colsize}{name}{description}
\newcommand{\defblock}[3]{
    \begin{longtable}{l p{#1}} 
        \textbf{#2} & #3
    \end{longtable}
}

%Various Definitions
\setcounter{tocdepth}{2}
\definecolor{light-gray}{gray}{0.5}

\titleformat{\chapter}
    {\normalfont\huge}  % format
    {\thechapter.}      % label
    {10pt}              % separation
    {\huge\it}          % before-code

\pagestyle{fancy}
\lhead{\color{light-gray}Ara Adkins}
\rhead{\color{light-gray}TODO THIS}
\cfoot{\thepage}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}

\setlength{\parindent}{0pt}
\setlength{\headheight}{14pt}

\hypersetup{
    colorlinks,
    linkcolor={blue!30!black},
    citecolor={blue!30!black},
    urlcolor={blue!80!black}
}

\makeatletter
\renewcommand\@dotsep{200}
\makeatother

\renewcommand{\labelenumii}{\theenumii}
\renewcommand{\theenumii}{\theenumi.\arabic{enumii}.}

% Listings Styles
\lstset{
    % How/what to match
    sensitive=true,
    % Border (above and below)
    frame=lines,
    % Extra margin on line (align with paragraph)
    xleftmargin=0.5cm,
    % Put extra space under caption
    belowcaptionskip=1\baselineskip,
    % Colors
    backgroundcolor=\color{sol-base3},
    basicstyle=\color{sol-base0}\ttfamily,
    keywordstyle=\color{sol-cyan},
    commentstyle=\color{sol-base01},
    stringstyle=\color{sol-blue},
    numberstyle=\color{sol-violet},
    identifierstyle=\color{sol-base00},
    % Break long lines into multiple lines?
    breaklines=true,
    % Show a character for spaces?
    showstringspaces=false,
    tabsize=4,
    numbers=left,
    numbersep=5pt,
    numberstyle=\tiny\color{sol-base1},
    rulecolor=\color{sol-base01},
    aboveskip=2em,
    belowskip=2em,
    upquote=true
}

% Title
% \pretitle{
% 	\begin{center}
% }
% \posttitle{
%     \end{center}
% }

\title{Specification and Formal Verification of Domain-Specific Languages through Automatic Compiler Generation in Haskell}
\author{Ara Adkins}
\date{\today}

% Glossaries
\makeglossaries
\include{resources/glossary}
\glsaddall % add ell items to the glossaries}

%Document
\begin{document}

\maketitle

\tableofcontents

\printglossaries

% - A detailed description and exploration of the problem that the project is seeking to address (2-3 pages + references)
% - Expand upon and modify the initial project idea in order to suit the student's knowledge and understanding. Deep understanding of the project to be attempted, clearly drawing on information from the sources. 
% - Should show evidence of additional reading and identification of background reading sources, with evidence that the background reading has clearly shaped the proposal.
% - Clear appreciation for other areas of knowledge that may be brought to bear on the project
% - Appreciations for the completion of the project on the users and / or research community.
% - External references and sources are appropriately cited and used, no use of inappropriate sources.
\chapter{Problem Description} % (fold)
\label{cha:problem_description}
This project aims to create a logical framework and tool for the formal verification of embedded, executable Domain-Specific Languages.
This is to allow the generation of provably correct, tailored programming languages for the encapsulation of domain logic inside another program.
These languages can be compiled through use of a Haskell metacompiler that takes both syntax and semantics for the Domain-Specific Language, generating executables. 

\section{An Introduction to Domain-Specific Languages} % (fold)
\label{sec:an_introduction_to_domain_specific_languages}
Modern software systems are increasing in complexity, with everything from flight computers to business software growing larger \citep{dvorak2009nasa}.
As domain logic is becoming integrated throughout systems, leading to tightly coupled code, there is increasing risk that changes to the software create modes of incorrect operation \cite{khawar2001developing}.\\

In reaction to the dispersion of domain logic throughout modern software systems, Domain-Specific Languages (DSLs) have seen ``a significant uptick in interest'' \citep{fowler2010domain}. 
A DSL is a limited, application-specific language that is embedded into another software system, providing a custom encoding of domain rules and logic often beyond the syntactic constraints of the host language \citep{Mernik:2005:DDL:1118890.1118892}.
In the use of a DSL, software systems are able to centralise their domain logic using a common syntax, making it simple to change rules for the operation of the program.\\

The term `Domain-Specific Language' is a broad one, encompassing a variety of embedded syntaxes for defining domain logic.
Fowler defines `internal' and `external' DSLs; an internal DSL is written in the host language and exposed via an API, also known as a fluent interface, while an external DSL is a language parsed independently of the host language \citep{fowler2010domain}.\\

In addition to their structure, Domain-Specific Languages can also be defined in terms of their `executability' \citep{Mernik:2005:DDL:1118890.1118892}.
Many DSLs are programming languages with `well-defined execution semantics', such as \LaTeX, a macro language for \TeX, and Template Haskell, which allows manipulation of Haskell code itself using Haskell \citep{sheard2002template}.
As a counterpoint, some DSLs define configuration information for a software system, having no executable semantics of their own.

% section an_introduction_to_domain_specific_languages (end)

\section{The Need for Correct DSLs} % (fold)
\label{sec:the_need_for_correct_dsls}
Initial inspiration for this project was engendered by the observation of a financial technology company using the general-purpose programming language OCaml for runtime configuration.
As a turing-complete programming language, this offered vastly greater expressive power than necessary for the domain in which it was applied, thus increasing the potential for bugs in the domain logic, as suggested by \cite{subramanyam2003empirical}.
If a capable DSL could be designed that could have formally verified properties, then it would be a much better fit to the domain while reducing the capabilities for bugs.\\

While the scope of common DSLs is necessarily very broad, encompassing everything from executable program logic to statically defined configuration, this project aims to focus on a small subset of the DSL universe.
As formal correctness only applies to executable programs, this project will focus on external, executable DSLs. 
While analysis could benefit internal DSLs as well, they are much better suited for analysis by traditional code-review mechanisms, and cannot satisfy the requirements for this project.\\

Even with the ``detailed analysis and structuring of the application domain'' \citep{van2000domain} performed when initially defining the DSL, it can be difficult to verify the correctness of the resulting language. 
While current methods can utilise code-review to attempt to analyse the correctness of the DSL implementation, a lack of understanding of the domain by the application developers may allow logic errors to be missed. 
This is because the domain logic is often embodied by expert knowledge, as found by \cite{studer1998knowledge}, and it can be difficult to verify the language implementation with those domain experts through code-review due to a lack of understanding.
As core domain logic, often integral to the program, is embedded in this DSL, it is instrumental that it be formally correct.\\

This project aims to provide a solution for the sixth step of DSL design as proposed by \cite{van2000domain}: ``design and implement a compiler that translates DSL programs''. 
While the logic that the DSL aims to encode can be verified with domain experts, it is difficult to verify the resulting implementation.
While the language semantics are integral to the design of the language, designing the semantic analysis and verification into the compiler tool will allow the automatic generation of DSLs from specification, removing the potential for errors introduced during the implementation.
An automated system offers benefits over manual review, as the domain experts can work with the DSL designers to encode the correct semantics, before it becomes an executable program.

% section the_need_for_correct_dsls (end)

\section{Verification of DSL Semantics} % (fold)
\label{sec:verification_of_dsl_semantics}
While it would be desirable to design a system for verification of arbitrary DSL semantics, there are certain classes of problem in semantic verification which are not decidable \citep{abdulla1994undecidable}. \\

This is most elegantly expressed in the duality of data and codata, or recursion and corecursion. 
While recursively defined structures are decomposed from a state into certain `base-cases', providing a well-defined termination property, corecursion aims to start from a `base-case' and build data from there \citep{hinze2010reasoning}.
As corecursion is dual to recursion, codata is the potentially infinite dual to data, which is necessarily finite. \\

If the program semantics are limited to those that can be defined recursively rather than corecursively; that is, via structural induction rather than coinduction, then termination can be proven for such programs \citep{nordstrom1988terminating}.\\

In the limited domain of recursively defined program semantics, this project aims to build on the of Peter Mosses, drawing on his work with his \textit{PlanCompS} project for specifying modular programming language semantics \cite{doh2001composing}.
It will also draw upon the work of Godel's `System-T', a theory of arithmetic for finite types that allows reasoning about arbitrarily-sized, finite data structures via recursion \cite{girard1989proofs,alves2010godel}.\\

The aim is to define a set of what Mosses terms `funcons' (\textit{fundamental constructs}); a set of semantic building blocks that can all be proven to terminate \cite{churchill2014reusable}.
Alongside a metalanguage that is able to specify both syntax and semantics for the DSL, the project aims to create a toolchain for verifying the DSL semantics.\\

From the metalanguage definition of syntax and semantics, the project toolchain will act as a metacompiler \cite{Mandell:1966:MDA:800267.810785} for the DSL.
The provided semantics will allow decomposition, through structural induction, into the funcons.
The funcons and associated program code can then be composed to generate the program that matches the semantics defined for the DSL.\\

% section verification_of_dsl_semantics (end)

\section{The Novel Contribution of this Project} % (fold)
\label{sec:the_novel_contribution_of_this_project}
This project aims to make a novel research contribution through the production of two main components:
\begin{itemize}
    \item \textbf{A DSL Metalanguage:} A metalanguage for the specification of the syntax of a DSL, along with its associated semantics. 
    The syntactic notation will likely be based upon the Extended Backus-Naur Form, a metasyntax notation for expressing languages whose syntax matches a context-free grammar. 
    The corresponding semantic notations will likely be based on the conventional big-step operational semantics \citep{Schmidt:2003:PLS:1074100.1074733} devised for automatic compiler generation \citep{diehl1996semantics}.
    \item \textbf{A Metacompiler:} This metacompiler program will take a DSL description in the above metalanguage, and a program in the described DSL, and produce a working executable from this. 
\end{itemize}

Through limiting scope to just recursively defined semantic constructs, and omitting consideration of corecursive constructs, this project will be able to produce a useful metacompiler for a set of language semantics within which arbitrary DSLs can be constructed. 

% section the_novel_contribution_of_this_project (end)

\section{Project Objectives} % (fold)
\label{sec:project_objectives}
The main objectives of this project are as follows:
\begin{itemize}
    \item Conduct research on methods for the description of fundamental program syntax and semantics.
    \item Use the knowledge gained from this research to develop the metalanguage \textit{Absol} to describe the syntax and semantics of an arbitrary domain-specific language.
    \item Define a set of basic \textit{funcons} as fundamental building blocks for programs with purely recursively defined semantics. 
    These building blocks will have trivially true termination properties.
    \item Describe methods for semantic decomposition, allowing the program semantics specified using \textit{Absol} to be decomposed to the \textit{funcons}, allowing termination proof for the semantics via structural induction.
    Structurally recursive semantic definitions allow us to decompose the semantics to the \textit{funcons}, as long as we can express all DSL semantics in terms of these building blocks. 
    \item Development of a basic DSL using the metalanguage.
    \item Development of a minimum working example for the metacompiler using hand-implemented semantics based on the \textit{Absol} metalanguage.
    \item Development of a working metacompiler that can ingest a description of the DSL's syntax and semantics using \textit{Absol}, as well as a program in the DSL itself, and produce a working executable program.
    \item Evaluate the metacompiler in terms of real-world performance and theoretical contribution.
\end{itemize}

% section project_objectives (end)

% chapter problem_description (end)

% =============================================================================

% - A high-level requirements specification identifying the main deliverables and objectives for the project (1-3 pages)
% - Requirements attempt to bound the project rigorously, including scope constraints.
\chapter{Requirements Specification} % (fold)
\label{cha:requirements_specification}
This section outlines the high-level requirements for the project.

\section{Functional DSL} % (fold)
\label{sec:functional_dsl}
The DSL that will be devised for the project falls into two phases. 
The initial phase involves a very simple language that is capable of basic operations and data traversal, and is intended to be used for the hand-implemented metacompiler proof-of-concept.
The more advanced phase brings additional language features if time permits, integrating them into the language to test the capabilities of the metacompiler.

\subsubsection{Simple DSL} % (fold)
\label{ssub:simple_dsl}
The basic DSL has a set of functional and non-functional requirements.

\subsubsection{Functional Requirements} % (fold)
\label{ssub:functional_requirements_simple}
The basic DSL will provide:
\begin{itemize}
    \item Simple data types (integers, floating-point numbers, strings), with operations defined on those data types.
    \item An error-handling mechanism
    \item Functions that can take arguments and return a tuple of result and error state. 
    These can be defined by the users.
    \item A single collection data type, allowing arbitrary-length data.
    \item \lstinline{map(fn, data)}, an operation that allows traversal of data structures.
\end{itemize}

% subsubsection functional_requirements (end)

\subsubsection{Non-Functional Requirements} % (fold)
\label{ssub:non_functional_requirements_simple}
The non-functional requirements of the basic DSL are:
\begin{itemize}
    \item A statically typed type system.
    \item The DSL will be purely functional, with all functions defined to be pure, total functions.
\end{itemize}

% subsubsection non_functional_requirements (end)

% subsubsection simple_dsl (end)

\subsection{Extended DSL} % (fold)
\label{sub:extended_dsl}
The extended DSL has all of the requirements of the simple DSL (Section~\ref{ssub:simple_dsl}), and the following.

\subsubsection{Functional Requirements} % (fold)
\label{ssub:functional_requirements_extended}
On top of the functionality defined for the basic DSL, the extended DSL will provide:
\begin{itemize}
    \item Higher-order functional constructs, allowing functions to be first-class types in the language, and be passed as arguments.
    \item User-definable data-types (e.g. ADTs)
\end{itemize}

% subsubsection functional_requirements (end)

\subsubsection{Non-Functional Requirements} % (fold)
\label{ssub:non_functional_requirements_extended}
If time permits, the extended DSL may also provide:
\begin{itemize}
    \item Type-inference functionality utilising the Haskell type-inference engine (Hindley-Milner Type Inference).
    \item State propagation via an extension of the error mechanism.
\end{itemize}

% subsubsection non_functional_requirements (end)

% subsection extended_dsl (end)

% section functional_dsl (end)

\section{DSL Metalanguage --- Absol} % (fold)
\label{sec:dsl_metalanguage_absol}
The metalanguage has the following requirements.

\subsection{Metalanguage: Functional Requirements} % (fold)
\label{sub:metalanguage_functional_requirements}
The metalanguage will satisfy the following requirements:
\begin{itemize}
    \item Provide a syntax capable of specifying both the syntax and semantics of the DSL being expressed.
    \item Provide a set of funcons; building blocks from which the computational semantics of the DSL can be composed. 
    \item Have provable termination properties for these funcons (i.e. the funcons should be total functions and compositions of total functions are total).
\end{itemize}

% subsection metalanguage_functional_requirements (end)

\subsection{Metalanguage: Non-Functional Requirements} % (fold)
\label{sub:metalanguage_non_functional_requirements}
The metalanguage may satisfy the following requirements:
\begin{itemize}
    \item The syntax should be as natural as possible.
    \item The syntax should be intuitive where possible, drawing on existing concepts for specifying both syntax (e.g. EBNF) and semantics (e.g. big-step operational semantics).
    \item The language may be more general than the specific application for which it is being developed.
\end{itemize}

% subsection metalanguage_non_functional_requirements (end)

% section dsl_metalanguage_absol (end)

\section{DSL Metacompiler} % (fold)
\label{sec:dsl_metacompiler}
The DSL metacompiler will satisfy the following requirements.

\subsection{Metacompiler: Functional Requirements} % (fold)
\label{sub:metacompiler_functional_requirements}
The metacompiler will:
\begin{itemize}
    \item Take both a metalanguage specification and DSL source file as input.
    \item Provide a mechanism to parse the syntax specified in the metalanguage input file.
    \item Provide a mechanism to parse the semantics specified in the metalanguage input file and decompose these into funcons.
    \item Build the program semantics for the input source file using these funcons.
    \item Output a Haskell module containing executable code for the DSL that can then be compiled using GHC for use with a Haskell program or other program that provides a C-like foreign-function interface (FFI).
    \item Alternatively, the metacompiler process may generate a compiler for the DSL in question, requiring a two-step process to generate the Haskell module as output. 
\end{itemize}

% subsection metacompiler_functional_requirements (end)

\subsection{Metacompiler: Non-Functional Requirements} % (fold)
\label{sub:metacompiler_non_functional_requirements}
The metacompiler will:
\begin{itemize}
    \item Be built using a sensible, modular design.
    \item Be designed with extensibility in mind.
\end{itemize}

% subsection metacompiler_non_functional_requirements (end)
% section dsl_metacompiler (end)

\section{Project Scope} % (fold)
\label{sec:project_scope}
While this project is operating in an area of active research, the scope has been intentionally constrained.
The following factors act to constrain project scope:
\begin{itemize}
    \item \textbf{Static Typing:} Dealing with dynamic typing would impose significant constraints on the design of the metacompiler, adding additional complexity to its operation.
    Ensuring this worked correctly would likely take more time than is available for the project.
    \item \textbf{No Codata:} While general-purpose programming languages have the ability to deal with codata and infinite data structures (e.g. streams, I/O), this project will omit this ability
    This is for two reasons:
    \begin{enumerate}
        \item It is unlikely to be useful for DSLs, as the DSL components can be called from the general-purpose programming language in which it is embedded.
        \item Termination properties cannot be proved for codata, meaning that not all programs in DSLs where codata was allowed could be proved to be correct.
    \end{enumerate}
    \item \textbf{Performance:} The project is not aiming to target performance and optimisation for the metacompiling process or the generator itself beyond what is afforded by GHCs optimising compiler.
    \item \textbf{No Consideration of Turing-Complete Programming Languages:} The project does not aim to consider turing-complete programming languages as part of its scope, mainly because codata is required to be turing complete.
\end{itemize}

% section project_scope (end)

% chapter requirements_specification (end)

% =============================================================================

% - A *detailed* project plan using appropriate techniques (e.g. Gantt Chart) that identifies the tasks you will undertake and the initial time allocation on these tasks
% - Project plan identifies major steps and decomposes these appropriately.
\chapter{Project Plan} % (fold)
\label{cha:project_plan}
This project plan aims to describe the intended progress of the project, including any planned contingencies.
It highlights the major phases of the project, and also the major waypoints on the way.

% chapter project_plan (end)

% =============================================================================

% - A list of resources required to complete the project along with their availabilities.
\chapter{Resources} % (fold)
\label{cha:resources}
Due to the highly theoretical nature of this project, it requires little in terms of software resources, and no equipment resources for project completion.

\section{Software Resources} % (fold)
\label{sec:software_resources}
The major software resources required for the completion of this project are:
\begin{itemize}
    \item \textbf{The Glasgow Haskell Compiler:} GHC is the most advanced Haskell compiler currently available, providing multiple extensions on the Haskell language that will be invaluable in the project.
    The metaprogramming facilities devised by \cite{sheard2002template} will be valuable in the implementation of the metacompiler. 
    \item \textbf{The Parsec Parsing Library:} Parsec is an industrial-strength, monadic, parser combinator library with the ability to parse Context-Sensitive and Infinite-Lookahead grammars.
    Parsec will be used to simplify the parsing routines for both the syntax and semantics specified by the \textit{Absol} metalanguage.
    \item \textbf{Stack:} A modern build tool for Haskell, providing totally reproducible builds. 
    It also supports regular unit testing and comprehensive release management.
    \item \textbf{Sublime Text 3:} A modern, extensible text editor with excellent performance characteristics.
    It will be used for working on the code portions of the project.
    \item \textbf{SublimeHaskell Haskell Toolchain:} A toolchain to support writing complex Haskell projects. 
    It provides semantic completion, refactoring support, linting, syntax styling and full type-inference, as well as integrating Haskell build tools with Sublime Text.
\end{itemize}

% section software_resources (end)

\section{Personnel Resources} % (fold)
\label{sec:personnel_resources}
While the project should be able to proceed without close support of personnel, it will be useful to have access to:
\begin{itemize}
    \item \textbf{Prof. Guy McCusker (Project Supervisor):} The project is highly theoretical, and there is the potential for a few instances where theoretical concepts found in various resources will required additional explanation or clarification.
    \item \textbf{Prof. Peter Mosses (Swansea):} This project builds heavily upon his work with \textit{PlanCompS}, and it may be useful to be in communication with him to discuss ideas and request clarification on his work where necessary.
\end{itemize}

% section personnel_resources (end)

- May be useful to contact mosses. 

% chapter resources (end)

% BIBLIOGRAPHY
\bibliographystyle{abbrvnat}
\bibliography{resources/bibliography}

\end{document}
